<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Basic Keyword Frequency Sorter</title>
</head>
<body>
  <div>
    <div>
      Basic Keyword Frequency Sorter
    </div>
    <br />
    <div class="button">
      <button class="button">Click me</button>
    </div>
    <pre id="log"></pre>
  </div>
  <script>
    const button = document.querySelector(".button");
    const words = document.querySelector(".words")

    button.addEventListener("click", () => {
      wordFilter()
    });

    

    const wordFilter = () => {
      let keyword = "was";
      let s = "It was a dark and stormy night.";
      let matchingWords = s.split(/\W+/).filter((word) => word.length > 0);
      // let matchingWords = s.split(/\W+/).filter((word) => word === keyword);
      console.log(matchingWords);
    }

    const wordFrequency = () => {
      /* Below is a regular expression that finds alphanumeric characters
       Next is a string that could easily be replaced with a reference to a form control
       Lastly, we have an array that will hold any words matching our pattern */
    var pattern = /\w+/g,
        string = "I I am am Am yes yes.",
        matchedWords = string.match( pattern );

    /* The Array.prototype.reduce method assists us in producing a single value from an
       array. In this case, we're going to use it to output an object with results. */
    var counts = matchedWords.reduce(function ( stats, word ) {

        /* `stats` is the object that we'll be building up over time.
           `word` is each individual entry in the `matchedWords` array */
        if ( stats.hasOwnProperty( word ) ) {
            /* `stats` already has an entry for the current `word`.
               As a result, let's increment the count for that `word`. */
            stats[ word ] = stats[ word ] + 1;
        } else {
            /* `stats` does not yet have an entry for the current `word`.
               As a result, let's add a new entry, and set count to 1. */
            stats[ word ] = 1;
        }

        /* Because we are building up `stats` over numerous iterations,
           we need to return it for the next pass to modify it. */
        return stats;
    }, {} );

    /* Now that `counts` has our object, we can log it. */
    console.log( counts )
    }

    // let string = "What if I wanted to go home tonight but tonight was not the night to be home"

    // const wordFreq = () => {
    // let string = "What if I wanted to go Home tonight but tonight was not the night to be home"
    // const words = string.replace(/[.]/g, '').split(/\s/);
    // const freqMap = {};
    // words.forEach((w) => {
    //     if (!freqMap[w]) {
    //         freqMap[w] = 0;
    //     }
    //     console.log(freqMap[w]+1, w);
    //     freqMap[w] += 1;

    //   });
    //   console.log({freqMap});
    // return freqMap;

    // }

    
    // const filteredWords = words.filter((word) => {
    //   config.keywords.some((keyword) => {
    //     word.toLowerCase().includes(keyword.toLowerCase());
    //   })
    //   console.log(filteredWords)
    // });

    // console.log(filteredWords)

// Dope console.log to JSON function
    (function () {
    var old = console.log;
    var logger = document.getElementById('log');
    console.log = function () {
      for (var i = 0; i < arguments.length; i++) {
        if (typeof arguments[i] == 'object') {
            logger.innerHTML += (JSON && JSON.stringify ? JSON.stringify(arguments[i], undefined, 2) : arguments[i]) + '<br />';
        } else {
            logger.innerHTML += arguments[i] + '<br />';
        }
      }
    }
})();

  </script>
</body>
</html>